{"success":true,"html":"<!DOCTYPE html>\n<html>\n  <head>\n    <!--BEGIN You must not change anything in head tag, use them as reference only-->\n    <meta charset=\"utf-8\" />\n    <meta\n      content=\"width=device-width, initial-scale=1.0, user-scalable=no\"\n      name=\"viewport\"\n    />\n    <title>Generated Game</title>\n    <style>\n      /* Base resets */\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n        background-color: #1a1a2e;\n        font-family: \"Orbitron\", sans-serif;\n      }\n\n      /* All screens fill entire viewport; now scrollable if content is too tall */\n      .screen {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        overflow-y: auto; /* Allow vertical scrolling on smaller screens */\n      }\n\n      /* Screens become visible with .active */\n      .screen.active {\n        display: flex !important;\n      }\n\n      /* Generic container styling */\n      .container {\n        max-width: 600px;\n        width: 90%;\n        margin: 0 auto;\n        text-align: center;\n        box-sizing: border-box;\n        color: #fff;\n        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n      }\n\n      /* Buttons */\n      button {\n        background: linear-gradient(135deg, #283c86 0%, #45a247 100%);\n        border: 2px solid #fff;\n        border-radius: 8px;\n        color: #fff;\n        font-family: \"Orbitron\", sans-serif;\n        font-size: clamp(14px, 3vw, 20px);\n        text-transform: uppercase;\n        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);\n        margin: 6px;\n        cursor: pointer;\n        transition: all 0.3s ease;\n        padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 30px);\n      }\n      button:hover {\n        background: linear-gradient(135deg, #45a247 0%, #283c86 100%);\n        transform: translateY(-2px);\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n      }\n      button:active {\n        transform: scale(0.95);\n      }\n\n      /* START MENU SCREEN (Active by default) */\n      #start-menu-screen .container {\n        background-image: url(\"./images/start-screen-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #start-menu-screen .container {\n          background-image: url(\"./images/start-screen-background-tablet.png\");\n        }\n      }\n      /* Updated game title for Chroma Shift */\n      #game-title {\n        font-size: 48px;\n        margin-bottom: 50px;\n        text-shadow: 2px 2px 4px #000000;\n      }\n\n      /* INSTRUCTIONS SCREEN */\n      #instructions-screen .container {\n        background-image: url(\"./images/instructions-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        position: relative;\n        padding: 25px;\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n        align-items: center;\n        overflow: hidden;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #instructions-screen .container {\n          background-image: url(\"./images/instructions-background-tablet.png\");\n        }\n      }\n      #instructions-screen .container::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.5);\n        z-index: 1;\n      }\n      #instructions-screen .container > * {\n        position: relative;\n        z-index: 2;\n      }\n      .instructions-content {\n        flex: 1;\n        width: 100%;\n        overflow-y: auto;\n        margin-bottom: 20px;\n        padding-right: 10px;\n        box-sizing: border-box;\n      }\n      #instructions-screen h2 {\n        font-size: 48px;\n        margin-bottom: 30px;\n      }\n\n      /* SETTINGS SCREEN */\n      #settings-screen .container {\n        background-image: url(\"./images/settings-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        position: relative;\n        padding: 25px;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #settings-screen .container {\n          background-image: url(\"./images/settings-background-tablet.png\");\n        }\n      }\n      #settings-screen .container::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.5);\n        z-index: 1;\n      }\n      #settings-screen .container > * {\n        position: relative;\n        z-index: 2;\n      }\n\n      /* GAME SCREEN */\n      #game-container {\n        flex-direction: column;\n        justify-content: flex-start;\n        align-items: center;\n        height: 100%;\n        width: 100%;\n        background-image: url(\"./images/splash-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #game-container {\n          background-image: url(\"./images/splash-background-tablet.png\");\n        }\n      }\n      /* The HUD (score) at top */\n      #hud {\n        display: none;\n        margin-top: 10px;\n        background-color: rgba(255, 255, 255, 0.9);\n        color: #1a1a2e;\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n        padding: 8px 20px;\n        border-radius: 8px;\n        text-align: center;\n      }\n      #hud-content {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        align-items: center;\n      }\n      #hud-content span {\n        margin: 5px 15px;\n      }\n\n      /* The main container for the game canvas, centered between HUD and bottom bar */\n      #game-container .container {\n        flex: 1;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        max-width: 600px;\n        width: 100%;\n      }\n      #game-canvas {\n        background-color: #333;\n        border: 10px solid #555;\n        border-radius: 10px;\n        box-shadow: 0 0 10px #000;\n        width: 100%;\n        aspect-ratio: 1 / 1;\n      }\n\n      /* Bottom bar with menu, instructions, restart */\n      #game-controls {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        align-items: center;\n        margin-bottom: 10px;\n      }\n\n      /* GAME OVER SCREEN */\n      #game-over-screen .container {\n        background-image: url(\"./images/game-over-screen-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #game-over-screen .container {\n          background-image: url(\"./images/game-over-screen-background-tablet.png\");\n        }\n      }\n      #game-over-message {\n        font-size: clamp(24px, 6vw, 40px);\n        color: #e94560;\n        margin-bottom: 40px;\n      }\n    </style>\n\n    <!-- Here is the integrated Platform setup -->\n    <script>\n      if (typeof Platform === \"undefined\") {\n        // Mock Platform API for local testing\n        var Platform = {\n          majorVersion: function () {\n            return 1;\n          },\n          minorVersion: function () {\n            return 0;\n          },\n          setHighestScore: function (score) {\n            localStorage.setItem(\"triviaHighScore\", score);\n          },\n          getHighestScore: function () {\n            return parseInt(localStorage.getItem(\"triviaHighScore\")) || 0;\n          },\n          getSoundVolume: function () {\n            const stored = localStorage.getItem(\"triviaVolume\");\n            if (stored === null) {\n              // If no volume in storage yet, default to 50\n              return 50;\n            }\n            const vol = parseInt(stored, 10);\n            if (isNaN(vol) || vol < 0 || vol > 100) {\n              // If the parsed value is invalid or out of 0-100, fallback\n              return 50;\n            }\n            return vol; // Even if vol = 0, we return 0 properly\n          },\n          setSoundVolume: function (volume) {\n            localStorage.setItem(\"triviaVolume\", volume);\n          },\n          getPreferredDifficulty: function () {\n            return 3; // Default to medium\n          },\n        };\n      }\n\n      if (Platform.majorVersion() != 1) {\n        throw \"This script requires Platform version 1.x\";\n      }\n      // Provided by Platform v1.x:\n      //  - Platform.majorVersion() => number\n      //  - Platform.minorVersion() => number\n      //  - Platform.setHighestScore(score: number) => void\n      //  - Platform.getHighestScore() => number\n      //  - Platform.getSoundVolume() => number  // 0-100\n      //  - Platform.getPreferredDifficulty() => number  // 0=easy,1=medium,2=hard,3=default\n    </script>\n    <!--END You must not change anything in head tag, use them as reference only-->\n  </head>\n  <body>\n    <!-- The ONLY screen that is active on load is the Start Menu -->\n    <div class=\"screen active\" id=\"start-menu-screen\">\n      <div class=\"container\">\n        <!-- Updated game title -->\n        <h1 id=\"game-title\">Chroma Shift</h1>\n        <button id=\"play-button\">Play</button>\n        <button id=\"settings-button\">Settings</button>\n        <button id=\"instructions-button\">Instructions</button>\n      </div>\n    </div>\n\n    <!-- SETTINGS SCREEN -->\n    <div class=\"screen\" id=\"settings-screen\">\n      <div class=\"container\">\n        <h2>Settings</h2>\n        <label for=\"volume-range\">Volume:</label>\n        <input\n          type=\"range\"\n          id=\"volume-range\"\n          min=\"0\"\n          max=\"100\"\n          step=\"1\"\n          value=\"100\"\n        />\n        <button class=\"main-menu-button\" id=\"settings-back-button\">Back</button>\n      </div>\n    </div>\n\n    <!-- INSTRUCTIONS SCREEN -->\n    <div class=\"screen\" id=\"instructions-screen\">\n      <div class=\"container\">\n        <div class=\"instructions-content\">\n          <h2>Instructions</h2>\n          <p>\n            Welcome to Chroma Shift! Instead of swapping adjacent tiles, select a tile \n            and then click/tap another tile in the same row or column to rotate that row or column by one space.\n          </p>\n          <p><strong>How to Play:</strong></p>\n          <ul>\n            <li>\n              Tap/click a tile to select its row or column.\n            </li>\n            <li>\n              Then tap/click another tile in the same row (rotate left/right) or\n              same column (rotate up/down) to trigger a rotation.\n            </li>\n            <li>\n              When a valid rotation creates three or more adjacent tiles of the same color,\n              they clear from the board.\n            </li>\n            <li>\n              Special blocks can be created and activated by larger matches.\n            </li>\n            <li>\n              Complete level objectives within the limited number of moves.\n            </li>\n          </ul>\n        </div>\n        <button class=\"main-menu-button\" id=\"instructions-back-button\">\n          Back\n        </button>\n      </div>\n    </div>\n\n    <!-- GAME SCREEN -->\n    <div class=\"screen\" id=\"game-container\">\n      <!-- HUD at top -->\n      <div id=\"hud\">\n        <div id=\"hud-content\">\n          <span id=\"score-display\">Score: 0</span>\n          <span id=\"moves-display\">Moves Left: 30</span>\n          <span id=\"high-score-display\">High Score: 0</span>\n        </div>\n      </div>\n\n      <!-- Canvas container in the center -->\n      <div class=\"container\">\n        <canvas id=\"game-canvas\"></canvas>\n      </div>\n\n      <!-- Buttons at the bottom -->\n      <div id=\"game-controls\">\n        <button id=\"game-menu-button\">Menu</button>\n        <button id=\"game-restart-button\">Restart</button>\n        <button id=\"game-instructions-button\">Instructions</button>\n      </div>\n    </div>\n\n    <!-- GAME OVER SCREEN -->\n    <div class=\"screen\" id=\"game-over-screen\">\n      <div class=\"container\">\n        <div id=\"game-over-message\">Game Over!</div>\n        <div id=\"final-score\">\n          Your Score: <span id=\"final-score-value\">0</span>\n        </div>\n        <div id=\"final-high-score\">\n          High Score: <span id=\"final-high-score-value\">0</span>\n        </div>\n        <button id=\"play-again-button\">Play Again</button>\n        <button class=\"main-menu-button\" id=\"game-over-main-menu-button\">\n          Main Menu\n        </button>\n      </div>\n    </div>\n\n    <!-- AUDIO -->\n    <audio id=\"background-music\" loop>\n      <source src=\"./audio/background-music.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"start-game-sound\">\n      <source src=\"./audio/start-game-sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"end-game-sound\">\n      <source src=\"./audio/end-game-sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"powerup-sound\">\n      <source src=\"./audio/retro_powerup_sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"clear-tiles-sound\">\n      <source src=\"./audio/retro_clear_sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n\n    <!-- MAIN SCRIPT -->\n    <script>\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        class GameUI {\n          constructor(game) {\n            this.game = game;\n            this.screens = {\n              startMenu: document.getElementById(\"start-menu-screen\"),\n              settings: document.getElementById(\"settings-screen\"),\n              instructions: document.getElementById(\"instructions-screen\"),\n              game: document.getElementById(\"game-container\"),\n              gameOver: document.getElementById(\"game-over-screen\"),\n            };\n            this.hud = document.getElementById(\"hud\");\n            this.gameControls = document.getElementById(\"game-controls\");\n            this.scoreDisplay = document.getElementById(\"score-display\");\n            this.movesDisplay = document.getElementById(\"moves-display\");\n            this.highScoreDisplay =\n              document.getElementById(\"high-score-display\");\n            this.finalScoreValue = document.getElementById(\"final-score-value\");\n            this.finalHighScoreValue = document.getElementById(\n              \"final-high-score-value\"\n            );\n\n            // Settings\n            this.volumeRange = document.getElementById(\"volume-range\");\n\n            // Audio\n            this.backgroundMusic = document.getElementById(\"background-music\");\n            this.powerupSound = document.getElementById(\"powerup-sound\");\n            this.startGameSound = document.getElementById(\"start-game-sound\");\n            this.endGameSound = document.getElementById(\"end-game-sound\");\n            this.clearTilesSound = document.getElementById(\"clear-tiles-sound\");\n\n            // Initialize volume\n            const initialVolume = Platform.getSoundVolume() / 100;\n            this.setVolume(initialVolume);\n            this.volumeRange.value = initialVolume * 100;\n\n            // Listen for volume change\n            this.volumeRange.addEventListener(\"input\", (e) => {\n              const volume = e.target.value / 100;\n              this.setVolume(volume);\n              Platform.setSoundVolume(e.target.value); // persist new volume\n            });\n          }\n\n          setVolume(volume) {\n            this.backgroundMusic.volume = volume;\n            this.powerupSound.volume = volume;\n            this.startGameSound.volume = volume;\n            this.endGameSound.volume = volume;\n            this.clearTilesSound.volume = volume;\n          }\n\n          swapToScreen(screenName) {\n            // Hide all screens\n            Object.values(this.screens).forEach((scr) =>\n              scr.classList.remove(\"active\")\n            );\n            // Show the requested screen\n            this.screens[screenName].classList.add(\"active\");\n\n            if (screenName === \"game\") {\n              this.hud.style.display = \"block\";\n              // Ensure canvas reinitialized\n              this.game.logic.initCanvasSize();\n              this.game.logic.draw();\n            } else {\n              this.hud.style.display = \"none\";\n            }\n          }\n\n          startGame() {\n            this.swapToScreen(\"game\");\n            this.updateHUD();\n            if (this.backgroundMusic) {\n              this.backgroundMusic.play();\n            }\n          }\n\n          endGame() {\n            this.playEndGameSound();\n            if (this.backgroundMusic) {\n              this.backgroundMusic.pause();\n              this.backgroundMusic.currentTime = 0;\n            }\n            this.swapToScreen(\"gameOver\");\n            this.finalScoreValue.textContent = this.game.score;\n            this.finalHighScoreValue.textContent = this.game.highScore;\n          }\n\n          mainMenu() {\n            if (this.backgroundMusic) {\n              this.backgroundMusic.pause();\n              this.backgroundMusic.currentTime = 0;\n            }\n            this.swapToScreen(\"startMenu\");\n          }\n\n          playAgain() {\n            this.game.resetGame();\n            this.swapToScreen(\"game\");\n          }\n\n          settings() {\n            this.swapToScreen(\"settings\");\n          }\n\n          instructions() {\n            this.swapToScreen(\"instructions\");\n          }\n\n          updateHUD() {\n            this.scoreDisplay.textContent = \"Score: \" + this.game.score;\n            this.movesDisplay.textContent =\n              \"Moves Left: \" + this.game.logic.movesLeft;\n            this.highScoreDisplay.textContent =\n              \"High Score: \" + this.game.highScore;\n          }\n\n          playPowerupSound() {\n            this.powerupSound.currentTime = 0;\n            this.powerupSound.play();\n          }\n\n          playStartGameSound() {\n            this.startGameSound.currentTime = 0;\n            this.startGameSound.play();\n          }\n\n          playEndGameSound() {\n            this.endGameSound.currentTime = 0;\n            this.endGameSound.play();\n          }\n\n          playClearTilesSound() {\n            this.clearTilesSound.currentTime = 0;\n            this.clearTilesSound.play();\n          }\n        }\n\n        class GameLogic {\n          constructor(game) {\n            this.game = game;\n            this.canvas = document.getElementById(\"game-canvas\");\n            this.context = this.canvas.getContext(\"2d\");\n            this.gridSize = 10;\n            this.tileTypes = 6;\n            this.tileSize = null;\n            this.grid = [];\n            this.selectedTile = null;\n            this.animations = [];\n            this.score = 0;\n            this.highScore = 0;\n            this.movesLeft = 30;\n            this.isAnimating = false;\n            this.pendingSpecialTiles = [];\n            this.lastSwappedTile = null;\n            this.delayCounter = 0;\n            this.pendingAnimations = null;\n            this.specialBlocks = [\"BOMB\", \"LIGHTNING\", \"FIRECRACKER\"];\n            this.initCanvasSize();\n            window.addEventListener(\"resize\", () => {\n              this.initCanvasSize();\n              this.draw();\n            });\n            this.init();\n          }\n\n          initCanvasSize() {\n            const container = document.querySelector(\n              \"#game-container .container\"\n            );\n            const containerWidth = container.clientWidth;\n            const containerHeight = container.clientHeight;\n            const canvasSize = Math.min(containerWidth, containerHeight);\n            this.canvas.width = canvasSize;\n            this.canvas.height = canvasSize;\n            this.tileSize = canvasSize / this.gridSize;\n          }\n\n          init() {\n            this.generateGrid();\n            this.bindEvents();\n            this.update();\n            this.draw();\n          }\n\n          resetGame() {\n            this.score = 0;\n            this.movesLeft = 30;\n            this.grid = [];\n            this.selectedTile = null;\n            this.animations = [];\n            this.isAnimating = false;\n            this.pendingSpecialTiles = [];\n            this.lastSwappedTile = null;\n            this.delayCounter = 0;\n            this.pendingAnimations = null;\n            this.generateGrid();\n            this.game.ui.updateHUD();\n          }\n\n          generateGrid() {\n            for (let x = 0; x < this.gridSize; x++) {\n              this.grid[x] = [];\n              for (let y = 0; y < this.gridSize; y++) {\n                this.grid[x][y] = this.getRandomTile();\n              }\n            }\n            this.removeInitialMatches();\n          }\n\n          getRandomTile() {\n            return {\n              type: Math.floor(Math.random() * this.tileTypes),\n              special: null,\n              x: 0,\n              y: 0,\n              isMoving: false,\n              moveTo: null,\n            };\n          }\n\n          removeInitialMatches() {\n            let matches = this.findAllMatches();\n            while (matches.length > 0) {\n              for (let match of matches) {\n                for (let tile of match.tiles) {\n                  this.grid[tile.x][tile.y] = this.getRandomTile();\n                }\n              }\n              matches = this.findAllMatches();\n            }\n          }\n\n          bindEvents() {\n            let isTouchDevice =\n              \"ontouchstart\" in window || navigator.msMaxTouchPoints;\n\n            if (isTouchDevice) {\n              this.canvas.addEventListener(\n                \"touchstart\",\n                this.onTouchStart.bind(this),\n                { passive: false }\n              );\n              // Disable move and end events for rotation mechanic\n              this.canvas.addEventListener(\n                \"touchmove\",\n                (e) => { e.preventDefault(); },\n                { passive: false }\n              );\n              this.canvas.addEventListener(\n                \"touchend\",\n                (e) => { this.selectedTile = null; },\n                { passive: false }\n              );\n            } else {\n              // For desktop, only use onMouseDown to handle rotation selection.\n              this.canvas.addEventListener(\n                \"mousedown\",\n                this.onMouseDown.bind(this)\n              );\n              // Disable mousemove and mouseup events for rotation mechanic.\n              this.canvas.addEventListener(\"mousemove\", (e) => {}, false);\n              this.canvas.addEventListener(\"mouseup\", (e) => {\n                this.selectedTile = null;\n              }, false);\n            }\n          }\n\n          getTileUnderCursor(event) {\n            let rect = this.canvas.getBoundingClientRect();\n            let posX =\n              (event.clientX - rect.left) * (this.canvas.width / rect.width);\n            let posY =\n              (event.clientY - rect.top) * (this.canvas.height / rect.height);\n            let tileX = Math.floor(posX / this.tileSize);\n            let tileY = Math.floor(posY / this.tileSize);\n            return { x: tileX, y: tileY };\n          }\n\n          // Modified onMouseDown to handle row/column rotation\n          onMouseDown(e) {\n            if (this.isAnimating) return;\n            let pos = this.getTileUnderCursor(e);\n            if (!this.isValidTile(pos)) return;\n            if (!this.selectedTile) {\n              this.selectedTile = pos;\n              return;\n            }\n            if (pos.y === this.selectedTile.y) {\n              let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n              this.rotateRow(this.selectedTile.y, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else if (pos.x === this.selectedTile.x) {\n              let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n              this.rotateColumn(this.selectedTile.x, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else {\n              this.selectedTile = pos;\n            }\n          }\n\n          // Modified onTouchStart similar to onMouseDown for rotation\n          onTouchStart(e) {\n            if (this.isAnimating) return;\n            let touch = e.touches[0];\n            if (this.isTouchInCanvas(touch)) {\n              e.preventDefault();\n            }\n            let pos = this.getTileUnderCursor(touch);\n            if (!this.isValidTile(pos)) return;\n            if (!this.selectedTile) {\n              this.selectedTile = pos;\n              return;\n            }\n            if (pos.y === this.selectedTile.y) {\n              let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n              this.rotateRow(this.selectedTile.y, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else if (pos.x === this.selectedTile.x) {\n              let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n              this.rotateColumn(this.selectedTile.x, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else {\n              this.selectedTile = pos;\n            }\n          }\n\n          isValidTile(pos) {\n            return (\n              pos.x >= 0 &&\n              pos.x < this.gridSize &&\n              pos.y >= 0 &&\n              pos.y < this.gridSize\n            );\n          }\n\n          // New helper function to rotate a row by one space.\n          rotateRow(row, direction) {\n            if (direction === \"right\") {\n              const temp = this.grid[row][this.gridSize - 1];\n              for (let x = this.gridSize - 1; x > 0; x--) {\n                this.grid[row][x] = this.grid[row][x - 1];\n              }\n              this.grid[row][0] = temp;\n            } else if (direction === \"left\") {\n              const temp = this.grid[row][0];\n              for (let x = 0; x < this.gridSize - 1; x++) {\n                this.grid[row][x] = this.grid[row][x + 1];\n              }\n              this.grid[row][this.gridSize - 1] = temp;\n            }\n          }\n\n          // New helper function to rotate a column by one space.\n          rotateColumn(col, direction) {\n            if (direction === \"down\") {\n              const temp = this.grid[this.gridSize - 1][col];\n              for (let y = this.gridSize - 1; y > 0; y--) {\n                this.grid[y][col] = this.grid[y - 1][col];\n              }\n              this.grid[0][col] = temp;\n            } else if (direction === \"up\") {\n              const temp = this.grid[0][col];\n              for (let y = 0; y < this.gridSize - 1; y++) {\n                this.grid[y][col] = this.grid[y + 1][col];\n              }\n              this.grid[this.gridSize - 1][col] = temp;\n            }\n          }\n\n          findAllMatches() {\n            let matches = [];\n            // Horizontal matches\n            for (let y = 0; y < this.gridSize; y++) {\n              let matchLength = 1;\n              for (let x = 0; x < this.gridSize; x++) {\n                if (x < this.gridSize - 1) {\n                  let currentTile = this.grid[x][y];\n                  let nextTile = this.grid[x + 1][y];\n                  if (\n                    currentTile &&\n                    nextTile &&\n                    currentTile.type === nextTile.type\n                  ) {\n                    matchLength++;\n                  } else {\n                    if (matchLength >= 3) {\n                      let tiles = [];\n                      for (let i = x - matchLength + 1; i <= x; i++) {\n                        tiles.push({ x: i, y: y });\n                      }\n                      matches.push({\n                        type: this.grid[x][y].type,\n                        tiles: tiles,\n                      });\n                    }\n                    matchLength = 1;\n                  }\n                } else {\n                  if (matchLength >= 3) {\n                    let tiles = [];\n                    for (let i = x - matchLength + 1; i <= x; i++) {\n                      tiles.push({ x: i, y: y });\n                    }\n                    matches.push({\n                      type: this.grid[x][y].type,\n                      tiles: tiles,\n                    });\n                  }\n                  matchLength = 1;\n                }\n              }\n            }\n            // Vertical matches\n            for (let x = 0; x < this.gridSize; x++) {\n              let matchLength = 1;\n              for (let y = 0; y < this.gridSize; y++) {\n                if (y < this.gridSize - 1) {\n                  let currentTile = this.grid[x][y];\n                  let nextTile = this.grid[x][y + 1];\n                  if (\n                    currentTile &&\n                    nextTile &&\n                    currentTile.type === nextTile.type\n                  ) {\n                    matchLength++;\n                  } else {\n                    if (matchLength >= 3) {\n                      let tiles = [];\n                      for (let i = y - matchLength + 1; i <= y; i++) {\n                        tiles.push({ x: x, y: i });\n                      }\n                      matches.push({\n                        type: this.grid[x][y].type,\n                        tiles: tiles,\n                      });\n                    }\n                    matchLength = 1;\n                  }\n                } else {\n                  if (matchLength >= 3) {\n                    let tiles = [];\n                    for (let i = y - matchLength + 1; i <= y; i++) {\n                      tiles.push({ x: x, y: i });\n                    }\n                    matches.push({\n                      type: this.grid[x][y].type,\n                      tiles: tiles,\n                    });\n                  }\n                  matchLength = 1;\n                }\n              }\n            }\n            return matches;\n          }\n\n          mergeOverlappingMatches(matches) {\n            let mergedMatches = [];\n            for (let match of matches) {\n              let merged = false;\n              for (let existingMatch of mergedMatches) {\n                if (this.matchesOverlap(existingMatch, match)) {\n                  existingMatch.tiles = existingMatch.tiles.concat(\n                    match.tiles.filter(\n                      (t) =>\n                        !existingMatch.tiles.some(\n                          (et) => et.x === t.x && et.y === t.y\n                        )\n                    )\n                  );\n                  merged = true;\n                  break;\n                }\n              }\n              if (!merged) {\n                mergedMatches.push({\n                  type: match.type,\n                  tiles: [...match.tiles],\n                });\n              }\n            }\n            let hasMerged = true;\n            while (hasMerged) {\n              hasMerged = false;\n              for (let i = 0; i < mergedMatches.length; i++) {\n                for (let j = i + 1; j < mergedMatches.length; j++) {\n                  if (this.matchesOverlap(mergedMatches[i], mergedMatches[j])) {\n                    mergedMatches[i].tiles = mergedMatches[i].tiles.concat(\n                      mergedMatches[j].tiles.filter(\n                        (t) =>\n                          !mergedMatches[i].tiles.some(\n                            (et) => et.x === t.x && et.y === t.y\n                          )\n                      )\n                    );\n                    mergedMatches.splice(j, 1);\n                    hasMerged = true;\n                    break;\n                  }\n                }\n                if (hasMerged) break;\n              }\n            }\n            return mergedMatches;\n          }\n\n          matchesOverlap(a, b) {\n            for (let tile1 of a.tiles) {\n              for (let tile2 of b.tiles) {\n                if (tile1.x === tile2.x && tile1.y === tile2.y) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          }\n\n          processMatches(matches) {\n            let mergedMatches = this.mergeOverlappingMatches(matches);\n            let tilesToClear = [];\n            for (let match of mergedMatches) {\n              let tiles = match.tiles;\n              let matchLength = tiles.length;\n              for (let tile of tiles) {\n                if (\n                  !tilesToClear.some((t) => t.x === tile.x && t.y === tile.y)\n                ) {\n                  tilesToClear.push({ x: tile.x, y: tile.y });\n                }\n              }\n              if (matchLength >= 4) {\n                let specialType = null;\n                if (matchLength === 4) specialType = \"BOMB\";\n                else if (matchLength === 5) specialType = \"LIGHTNING\";\n                else if (matchLength >= 6) specialType = \"FIRECRACKER\";\n                if (specialType) {\n                  let specialTile = this.getSpecialTilePosition(tiles);\n                  this.pendingSpecialTiles.push({\n                    x: specialTile.x,\n                    y: specialTile.y,\n                    type: specialType,\n                    colorType: this.grid[specialTile.x][specialTile.y].type,\n                  });\n                }\n              }\n              this.game.score += tiles.length * 10;\n              this.game.ui.updateHUD();\n            }\n            this.game.ui.playClearTilesSound();\n            this.isAnimating = true;\n            this.delayCounter = 30;\n            this.pendingAnimations = {\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            };\n          }\n\n          getSpecialTilePosition(tiles) {\n            if (this.lastSwappedTile) {\n              for (let tile of tiles) {\n                if (\n                  tile.x === this.lastSwappedTile.x &&\n                  tile.y === this.lastSwappedTile.y\n                ) {\n                  return tile;\n                }\n              }\n            }\n            return tiles[Math.floor(tiles.length / 2)];\n          }\n\n          clearTiles(tiles) {\n            for (let tile of tiles) {\n              let x = tile.x;\n              let y = tile.y;\n              let currentTile = this.grid[x][y];\n              if (currentTile) {\n                if (currentTile.special) {\n                  this.activateSpecialTile(x, y);\n                }\n                this.grid[x][y] = null;\n              }\n            }\n          }\n\n          activateSpecialTile(x, y) {\n            let tile = this.grid[x][y];\n            if (tile && tile.special) {\n              this.game.ui.playPowerupSound();\n              if (tile.special === \"BOMB\") {\n                this.activateBomb(x, y);\n              } else if (tile.special === \"LIGHTNING\") {\n                this.activateLightning(x, y, tile.type);\n              } else if (tile.special === \"FIRECRACKER\") {\n                this.activateFirecracker(x, y);\n              }\n              this.grid[x][y] = null;\n            }\n          }\n\n          findAllMatches() { /* Already defined above */ }\n\n          activateBomb(x, y) {\n            let tilesToClear = [];\n            for (let i = x - 1; i <= x + 1; i++) {\n              for (let j = y - 1; j <= y + 1; j++) {\n                if (this.isValidTile({ x: i, y: j }) && this.grid[i][j]) {\n                  tilesToClear.push({ x: i, y: j });\n                }\n              }\n            }\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          activateLightning(x, y, type) {\n            let tilesToClear = [];\n            let cleared = 0;\n            for (let i = 0; i < this.gridSize; i++) {\n              for (let j = 0; j < this.gridSize; j++) {\n                if (this.grid[i][j] && this.grid[i][j].type === type) {\n                  tilesToClear.push({ x: i, y: j });\n                  cleared++;\n                  if (cleared >= 9) break;\n                }\n              }\n              if (cleared >= 9) break;\n            }\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          activateFirecracker(x, y) {\n            let tilesToClear = [];\n            for (let i = 0; i < this.gridSize; i++) {\n              if (this.grid[i][y]) {\n                tilesToClear.push({ x: i, y: y });\n              }\n            }\n            for (let j = 0; j < this.gridSize; j++) {\n              if (this.grid[x][j]) {\n                tilesToClear.push({ x: x, y: j });\n              }\n            }\n            tilesToClear = tilesToClear.filter(\n              (tile, index, self) =>\n                index ===\n                self.findIndex((t) => t.x === tile.x && t.y === tile.y)\n            );\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          fillEmptySpaces() {\n            let moved = false;\n            for (let x = 0; x < this.gridSize; x++) {\n              for (let y = this.gridSize - 1; y >= 0; y--) {\n                if (this.grid[x][y] === null) {\n                  for (let yy = y - 1; yy >= 0; yy--) {\n                    if (this.grid[x][yy] !== null) {\n                      this.grid[x][yy].isMoving = true;\n                      this.grid[x][yy].moveTo = { x: x, y: y };\n                      this.animations.push({\n                        type: \"fall\",\n                        tile: this.grid[x][yy],\n                        from: { x: x, y: yy },\n                        to: { x: x, y: y },\n                        progress: 0,\n                        duration: (yy - y) * 5,\n                      });\n                      this.grid[x][y] = this.grid[x][yy];\n                      this.grid[x][yy] = null;\n                      moved = true;\n                      break;\n                    }\n                  }\n                  if (this.grid[x][y] === null) {\n                    let newTile = this.getRandomTile();\n                    newTile.isMoving = true;\n                    newTile.moveTo = { x: x, y: y };\n                    this.grid[x][y] = newTile;\n                    this.animations.push({\n                      type: \"fall\",\n                      tile: newTile,\n                      from: { x: x, y: y - this.gridSize },\n                      to: { x: x, y: y },\n                      progress: 0,\n                      duration: (this.gridSize + y) * 5,\n                    });\n                    moved = true;\n                  }\n                }\n              }\n            }\n            if (this.pendingSpecialTiles.length > 0) {\n              for (let specialTileInfo of this.pendingSpecialTiles) {\n                let x = specialTileInfo.x;\n                let y = specialTileInfo.y;\n                this.grid[x][y] = {\n                  type: specialTileInfo.colorType,\n                  special: specialTileInfo.type,\n                  x: 0,\n                  y: 0,\n                  isMoving: false,\n                  moveTo: null,\n                };\n              }\n              this.pendingSpecialTiles = [];\n            }\n            return moved;\n          }\n\n          update() {\n            if (this.delayCounter > 0) {\n              this.delayCounter--;\n              if (this.delayCounter === 0 && this.pendingAnimations) {\n                this.animations.push(this.pendingAnimations);\n                this.pendingAnimations = null;\n              }\n            } else {\n              if (this.animations.length > 0) {\n                for (let i = this.animations.length - 1; i >= 0; i--) {\n                  let anim = this.animations[i];\n                  anim.progress++;\n                  if (anim.progress >= anim.duration) {\n                    this.animations.splice(i, 1);\n                    if (anim.type === \"swap\") {\n                      if (anim.reverse) {\n                        let temp =\n                          this.grid[anim.tiles[0].from.x][anim.tiles[0].from.y];\n                        this.grid[anim.tiles[0].from.x][anim.tiles[0].from.y] =\n                          this.grid[anim.tiles[1].from.x][anim.tiles[1].from.y];\n                        this.grid[anim.tiles[1].from.x][anim.tiles[1].from.y] =\n                          temp;\n                        this.isAnimating = false;\n                      } else {\n                        this.processSwap(anim.tiles[0].from, anim.tiles[0].to);\n                      }\n                    } else if (anim.type === \"fade\") {\n                      this.clearTiles(anim.tiles);\n                      if (!this.fillEmptySpaces()) {\n                        let newMatches = this.findAllMatches();\n                        if (newMatches.length > 0) {\n                          this.processMatches(newMatches);\n                        } else {\n                          this.isAnimating = false;\n                          if (this.movesLeft <= 0) {\n                            this.game.endGame();\n                          }\n                        }\n                      }\n                    } else if (anim.type === \"fall\") {\n                      anim.tile.isMoving = false;\n                      anim.tile.moveTo = null;\n                      if (this.animations.length === 0) {\n                        let newMatches = this.findAllMatches();\n                        if (newMatches.length > 0) {\n                          this.processMatches(newMatches);\n                        } else {\n                          this.isAnimating = false;\n                          if (this.movesLeft <= 0) {\n                            this.game.endGame();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            this.draw();\n            requestAnimationFrame(this.update.bind(this));\n          }\n\n          draw() {\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            for (let x = 0; x < this.gridSize; x++) {\n              for (let y = 0; y < this.gridSize; y++) {\n                let tile = this.grid[x][y];\n                if (tile) {\n                  this.drawTile(x, y, tile);\n                }\n              }\n            }\n            if (this.selectedTile) {\n              this.context.strokeStyle = \"#FFD700\";\n              this.context.lineWidth = 5;\n              this.context.strokeRect(\n                this.selectedTile.x * this.tileSize,\n                this.selectedTile.y * this.tileSize,\n                this.tileSize,\n                this.tileSize\n              );\n            }\n          }\n\n          drawTile(x, y, tile) {\n            let drawX = x;\n            let drawY = y;\n            for (let anim of this.animations) {\n              if (anim.type === \"swap\") {\n                for (let t of anim.tiles) {\n                  if (t.from.x === x && t.from.y === y) {\n                    let progress = anim.progress / anim.duration;\n                    if (anim.reverse) progress = 1 - progress;\n                    drawX = t.from.x + (t.to.x - t.from.x) * progress;\n                    drawY = t.from.y + (t.to.y - t.from.y) * progress;\n                  }\n                }\n              } else if (anim.type === \"fall\" && tile.isMoving) {\n                if (tile.moveTo) {\n                  let progress = anim.progress / anim.duration;\n                  drawX = anim.from.x;\n                  drawY = anim.from.y + (anim.to.y - anim.from.y) * progress;\n                }\n              } else if (anim.type === \"fade\") {\n                for (let fadeTile of anim.tiles) {\n                  if (fadeTile.x === x && fadeTile.y === y) {\n                    let alpha = 1 - anim.progress / anim.duration;\n                    this.context.globalAlpha = alpha;\n                  }\n                }\n              }\n            }\n            let colors = [\n              \"#FF0000\",\n              \"#00FF00\",\n              \"#0000FF\",\n              \"#FFFF00\",\n              \"#FF00FF\",\n              \"#00FFFF\",\n            ];\n            this.context.fillStyle = colors[tile.type];\n            this.context.fillRect(\n              drawX * this.tileSize,\n              drawY * this.tileSize,\n              this.tileSize,\n              this.tileSize\n            );\n            if (tile.special) {\n              this.context.fillStyle = \"#999999\";\n              this.context.font = `${this.tileSize / 2}px Arial`;\n              this.context.textAlign = \"center\";\n              this.context.textBaseline = \"middle\";\n              let text = \"\";\n              if (tile.special === \"BOMB\") text = \"B\";\n              else if (tile.special === \"LIGHTNING\") text = \"L\";\n              else if (tile.special === \"FIRECRACKER\") text = \"F\";\n              this.context.fillText(\n                text,\n                drawX * this.tileSize + this.tileSize / 2,\n                drawY * this.tileSize + this.tileSize / 2\n              );\n            }\n            this.context.globalAlpha = 1;\n            this.context.strokeStyle = \"#000\";\n            this.context.lineWidth = 2;\n            this.context.strokeRect(\n              drawX * this.tileSize,\n              drawY * this.tileSize,\n              this.tileSize,\n              this.tileSize\n            );\n          }\n        }\n\n        class Game {\n          constructor() {\n            this.score = 0;\n            this.highScore = Platform.getHighestScore() || 0;\n            this.ui = new GameUI(this);\n            this.logic = null;\n          }\n\n          startGame() {\n            this.score = 0;\n            if (this.logic) {\n              this.logic.resetGame();\n            } else {\n              this.logic = new GameLogic(this);\n            }\n            switch (Platform.getPreferredDifficulty()) {\n              case 0:\n                this.logic.movesLeft = 50;\n                break;\n              case 1:\n                this.logic.movesLeft = 30;\n                break;\n              case 2:\n                this.logic.movesLeft = 20;\n                break;\n              default:\n                this.logic.movesLeft = 30;\n                break;\n            }\n            this.ui.startGame();\n            this.ui.updateHUD();\n          }\n\n          endGame() {\n            this.ui.playEndGameSound();\n            if (this.score > this.highScore) {\n              this.highScore = this.score;\n              Platform.setHighestScore(this.highScore);\n            }\n            this.ui.endGame();\n          }\n\n          resetGame() {\n            this.score = 0;\n            this.ui.updateHUD();\n            this.logic.resetGame();\n          }\n\n          assignButtons() {\n            const playButton = document.getElementById(\"play-button\");\n            const settingsButton = document.getElementById(\"settings-button\");\n            const instructionsButton = document.getElementById(\n              \"instructions-button\"\n            );\n            const playAgainButton =\n              document.getElementById(\"play-again-button\");\n            const mainMenuButtons =\n              document.querySelectorAll(\".main-menu-button\");\n            const gameMenuButton = document.getElementById(\"game-menu-button\");\n            const gameRestartButton = document.getElementById(\n              \"game-restart-button\"\n            );\n            const gameInstructionsButton = document.getElementById(\n              \"game-instructions-button\"\n            );\n            const instructionsBackButton = document.getElementById(\n              \"instructions-back-button\"\n            );\n            const settingsBackButton = document.getElementById(\n              \"settings-back-button\"\n            );\n\n            playButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            settingsButton.addEventListener(\"click\", () => {\n              this.ui.settings();\n            });\n            instructionsButton.addEventListener(\"click\", () => {\n              this.ui.instructions();\n            });\n            playAgainButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            mainMenuButtons.forEach((button) =>\n              button.addEventListener(\"click\", () => {\n                this.ui.mainMenu();\n              })\n            );\n            gameMenuButton.addEventListener(\"click\", () => {\n              this.endGame();\n              this.ui.mainMenu();\n            });\n            gameRestartButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            gameInstructionsButton.addEventListener(\"click\", () => {\n              this.ui.instructions();\n            });\n            instructionsBackButton.addEventListener(\"click\", () => {\n              if (this.ui.screens.game.classList.contains(\"active\")) {\n                this.ui.swapToScreen(\"game\");\n              } else {\n                this.ui.mainMenu();\n              }\n            });\n            settingsBackButton.addEventListener(\"click\", () => {\n              this.ui.mainMenu();\n            });\n          }\n\n          prepareGame() {\n            this.assignButtons();\n            this.ui.highScoreDisplay.textContent =\n              \"High Score: \" + this.highScore;\n          }\n        }\n\n        const game = new Game();\n        game.prepareGame();\n      });\n    </script>\n  </body>\n</html>","raw":{"id":"chatcmpl-B1zrBixh1ed7K2BfYmOAKJZRGVVbY","object":"chat.completion","created":1739815805,"model":"o3-mini-2025-01-31","choices":[{"index":0,"message":{"role":"assistant","content":"1. Feasibility Analysis  \nThe requested modification is possible within the given constraints. We can repurpose the original swap‐based matching system into a row/column rotation mechanic by:  \n  • Changing the game title from “Retro Match 3 Puzzle” to “Chroma Shift”.  \n  • Replacing the mouse/touch “swap” logic with a “select–then–rotate” mechanic. In this design, the player first clicks (or touches) a tile to select its row/column; then a second click (or touch) on another tile in the same row or column determines the rotation direction (right/left for a row or down/up for a column).  \n  • Adding two helper methods (rotateRow() and rotateColumn()) inside the GameLogic class to update the board state by shifting all tiles in the chosen row/column by one space.  \n  • After performing the rotation, the game decrements the move count and runs the usual match-detection and clearing logic (including special tiles).  \n\n\"The requested modification is possible within the given constraints.\"  \n\n2. Step-by-Step Modification Guide  \n\nStep 1. Update the Game Title  \n• In the start menu HTML (inside the div with id=\"start-menu-screen\"), change the <h1> content from “Retro Match 3 Puzzle” to “Chroma Shift”. This informs players of the new game name.  \n\nExample change:  \n--------------------------------------------------------------  \n<!-- Change game title in start menu -->  \n<h1 id=\"game-title\">Chroma Shift</h1>  \n--------------------------------------------------------------  \n\nStep 2. Replace Swap Mechanic With Rotation Mechanic  \n• In the GameLogic class, we will modify the event handlers. Remove (or disable) the swap-related event code in onMouseMove and onMouseUp.  \n• In onMouseDown (and similarly in onTouchStart), implement logic so that:  \n  – If no tile is previously selected, store the clicked tile as selected.  \n  – If a tile is already selected and the new click is in the same row (i.e. same y) then determine the rotation direction (“right” if the new x is greater than the selected tile’s x and “left” otherwise), call a new rotateRow() method, and then update moves and check for matches.  \n  – If the tile is in the same column (i.e. same x), determine “down” (if new y is greater) or “up” (if new y is smaller), call rotateColumn() with that column and direction, update HUD and move count, then check for matches.  \n  – Otherwise, if the player clicks a tile outside the row/column of the current selection, update the selection to the new one.  \n\nWhy?  \nThese changes replace individual tile swaps with whole row or column rotations. One rotation (regardless of whether a match is formed) will count as one move.  \n\nStep 3. Add Helper Methods: rotateRow() and rotateColumn()  \n• In the GameLogic class, add two new methods that perform the grid rotation. For example:  \n\n  rotateRow(row, direction):  \n   – “right”: save the rightmost tile, shift all tiles one index to the right, then place the saved tile at the leftmost index.  \n   – “left”: do the opposite.  \n\n  rotateColumn(col, direction):  \n   – “down”: save the bottom tile, shift the column tiles down by one, then place the saved tile at the top.  \n   – “up”: do the opposite.  \n\nExample code block:  \n--------------------------------------------------------------  \n<script>\n  // Inside the GameLogic class, add these methods:\n  rotateRow(row, direction) {\n    if (direction === \"right\") {\n      const temp = this.grid[row][this.gridSize - 1];\n      for (let x = this.gridSize - 1; x > 0; x--) {\n        this.grid[row][x] = this.grid[row][x - 1];\n      }\n      this.grid[row][0] = temp;\n    } else if (direction === \"left\") {\n      const temp = this.grid[row][0];\n      for (let x = 0; x < this.gridSize - 1; x++) {\n        this.grid[row][x] = this.grid[row][x + 1];\n      }\n      this.grid[row][this.gridSize - 1] = temp;\n    }\n  }\n\n  rotateColumn(col, direction) {\n    if (direction === \"down\") {\n      const temp = this.grid[this.gridSize - 1][col];\n      for (let y = this.gridSize - 1; y > 0; y--) {\n        this.grid[y][col] = this.grid[y - 1][col];\n      }\n      this.grid[0][col] = temp;\n    } else if (direction === \"up\") {\n      const temp = this.grid[0][col];\n      for (let y = 0; y < this.gridSize - 1; y++) {\n        this.grid[y][col] = this.grid[y + 1][col];\n      }\n      this.grid[this.gridSize - 1][col] = temp;\n    }\n  }\n</script>\n--------------------------------------------------------------  \n\nStep 4. Modify Input Event Handling to Use Rotation  \n• In onMouseDown (and onTouchStart for touch devices), remove the swap-related logic; use the following outline:  \n\n--------------------------------------------------------------  \n<script>\n  // Update the onMouseDown method in the GameLogic class:\n  onMouseDown(e) {\n    if (this.isAnimating) return;\n    let pos = this.getTileUnderCursor(e);\n    if (!this.isValidTile(pos)) return;\n\n    // If nothing is selected, select this tile.\n    if (!this.selectedTile) {\n      this.selectedTile = pos;\n      return;\n    }\n    // If selection exists then check if this click is in the same row:\n    if (pos.y === this.selectedTile.y) {\n      let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n      this.rotateRow(this.selectedTile.y, direction);\n      this.movesLeft--;\n      this.game.ui.updateHUD();\n      let newMatches = this.findAllMatches();\n      if (newMatches.length > 0) {\n        this.processMatches(newMatches);\n      } else {\n        if (this.movesLeft <= 0) {\n          this.game.endGame();\n        }\n        // End rotation animation (if any)\n        this.isAnimating = false;\n      }\n      this.selectedTile = null; // reset selection\n    }\n    // If the click is in the same column:\n    else if (pos.x === this.selectedTile.x) {\n      let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n      this.rotateColumn(this.selectedTile.x, direction);\n      this.movesLeft--;\n      this.game.ui.updateHUD();\n      let newMatches = this.findAllMatches();\n      if (newMatches.length > 0) {\n        this.processMatches(newMatches);\n      } else {\n        if (this.movesLeft <= 0) {\n          this.game.endGame();\n        }\n        this.isAnimating = false;\n      }\n      this.selectedTile = null;\n    }\n    // Otherwise, update the selection.\n    else {\n      this.selectedTile = pos;\n    }\n  }\n\n  // For touch devices, modify onTouchStart similarly:\n  onTouchStart(e) {\n    if (this.isAnimating) return;\n    let touch = e.touches[0];\n    if (this.isTouchInCanvas(touch)) {\n      e.preventDefault();\n    }\n    let pos = this.getTileUnderCursor(touch);\n    if (!this.isValidTile(pos)) return;\n\n    if (!this.selectedTile) {\n      this.selectedTile = pos;\n      return;\n    }\n    if (pos.y === this.selectedTile.y) {\n      let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n      this.rotateRow(this.selectedTile.y, direction);\n      this.movesLeft--;\n      this.game.ui.updateHUD();\n      let newMatches = this.findAllMatches();\n      if (newMatches.length > 0) {\n        this.processMatches(newMatches);\n      } else {\n        if (this.movesLeft <= 0) {\n          this.game.endGame();\n        }\n        this.isAnimating = false;\n      }\n      this.selectedTile = null;\n    } else if (pos.x === this.selectedTile.x) {\n      let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n      this.rotateColumn(this.selectedTile.x, direction);\n      this.movesLeft--;\n      this.game.ui.updateHUD();\n      let newMatches = this.findAllMatches();\n      if (newMatches.length > 0) {\n        this.processMatches(newMatches);\n      } else {\n        if (this.movesLeft <= 0) {\n          this.game.endGame();\n        }\n        this.isAnimating = false;\n      }\n      this.selectedTile = null;\n    } else {\n      this.selectedTile = pos;\n    }\n  }\n</script>\n--------------------------------------------------------------  \n\n• You can comment out (or leave as no-ops) the onMouseMove and onMouseUp event code so that only onMouseDown (or onTouchStart) drives the rotation mechanic.\n\nStep 5. Visual & HUD Updates  \n• The existing HUD already displays the “Moves Left” counter and score. No further changes are needed here, although you might later expand the visual feedback (for example, highlighting the selected row/column or adding a rotation animation).  \n\n3. User Interaction Enhancements  \n• For desktop users, the updated onMouseDown now acts as the selection–rotation trigger.  \n• For touch devices, the event listener on touchstart follows the same logic.  \n• If desired, you may later add explicit visual indicators (or extra buttons) to guide players in selecting rows versus columns.  \n\n4. Final Export of Modified HTML  \nBelow is the entire updated HTML file with the changes integrated.  \n\n--------------------------------------------------------------\nHTML-CONTENT-EXPORT-BEGIN\n<!DOCTYPE html>\n<html>\n  <head>\n    <!--BEGIN You must not change anything in head tag, use them as reference only-->\n    <meta charset=\"utf-8\" />\n    <meta\n      content=\"width=device-width, initial-scale=1.0, user-scalable=no\"\n      name=\"viewport\"\n    />\n    <title>Generated Game</title>\n    <style>\n      /* Base resets */\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n        background-color: #1a1a2e;\n        font-family: \"Orbitron\", sans-serif;\n      }\n\n      /* All screens fill entire viewport; now scrollable if content is too tall */\n      .screen {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        overflow-y: auto; /* Allow vertical scrolling on smaller screens */\n      }\n\n      /* Screens become visible with .active */\n      .screen.active {\n        display: flex !important;\n      }\n\n      /* Generic container styling */\n      .container {\n        max-width: 600px;\n        width: 90%;\n        margin: 0 auto;\n        text-align: center;\n        box-sizing: border-box;\n        color: #fff;\n        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n      }\n\n      /* Buttons */\n      button {\n        background: linear-gradient(135deg, #283c86 0%, #45a247 100%);\n        border: 2px solid #fff;\n        border-radius: 8px;\n        color: #fff;\n        font-family: \"Orbitron\", sans-serif;\n        font-size: clamp(14px, 3vw, 20px);\n        text-transform: uppercase;\n        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);\n        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);\n        margin: 6px;\n        cursor: pointer;\n        transition: all 0.3s ease;\n        padding: clamp(8px, 2vw, 12px) clamp(16px, 4vw, 30px);\n      }\n      button:hover {\n        background: linear-gradient(135deg, #45a247 0%, #283c86 100%);\n        transform: translateY(-2px);\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n      }\n      button:active {\n        transform: scale(0.95);\n      }\n\n      /* START MENU SCREEN (Active by default) */\n      #start-menu-screen .container {\n        background-image: url(\"./images/start-screen-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #start-menu-screen .container {\n          background-image: url(\"./images/start-screen-background-tablet.png\");\n        }\n      }\n      /* Updated game title for Chroma Shift */\n      #game-title {\n        font-size: 48px;\n        margin-bottom: 50px;\n        text-shadow: 2px 2px 4px #000000;\n      }\n\n      /* INSTRUCTIONS SCREEN */\n      #instructions-screen .container {\n        background-image: url(\"./images/instructions-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        position: relative;\n        padding: 25px;\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n        align-items: center;\n        overflow: hidden;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #instructions-screen .container {\n          background-image: url(\"./images/instructions-background-tablet.png\");\n        }\n      }\n      #instructions-screen .container::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.5);\n        z-index: 1;\n      }\n      #instructions-screen .container > * {\n        position: relative;\n        z-index: 2;\n      }\n      .instructions-content {\n        flex: 1;\n        width: 100%;\n        overflow-y: auto;\n        margin-bottom: 20px;\n        padding-right: 10px;\n        box-sizing: border-box;\n      }\n      #instructions-screen h2 {\n        font-size: 48px;\n        margin-bottom: 30px;\n      }\n\n      /* SETTINGS SCREEN */\n      #settings-screen .container {\n        background-image: url(\"./images/settings-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        position: relative;\n        padding: 25px;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #settings-screen .container {\n          background-image: url(\"./images/settings-background-tablet.png\");\n        }\n      }\n      #settings-screen .container::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.5);\n        z-index: 1;\n      }\n      #settings-screen .container > * {\n        position: relative;\n        z-index: 2;\n      }\n\n      /* GAME SCREEN */\n      #game-container {\n        flex-direction: column;\n        justify-content: flex-start;\n        align-items: center;\n        height: 100%;\n        width: 100%;\n        background-image: url(\"./images/splash-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #game-container {\n          background-image: url(\"./images/splash-background-tablet.png\");\n        }\n      }\n      /* The HUD (score) at top */\n      #hud {\n        display: none;\n        margin-top: 10px;\n        background-color: rgba(255, 255, 255, 0.9);\n        color: #1a1a2e;\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n        padding: 8px 20px;\n        border-radius: 8px;\n        text-align: center;\n      }\n      #hud-content {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        align-items: center;\n      }\n      #hud-content span {\n        margin: 5px 15px;\n      }\n\n      /* The main container for the game canvas, centered between HUD and bottom bar */\n      #game-container .container {\n        flex: 1;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        max-width: 600px;\n        width: 100%;\n      }\n      #game-canvas {\n        background-color: #333;\n        border: 10px solid #555;\n        border-radius: 10px;\n        box-shadow: 0 0 10px #000;\n        width: 100%;\n        aspect-ratio: 1 / 1;\n      }\n\n      /* Bottom bar with menu, instructions, restart */\n      #game-controls {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        align-items: center;\n        margin-bottom: 10px;\n      }\n\n      /* GAME OVER SCREEN */\n      #game-over-screen .container {\n        background-image: url(\"./images/game-over-screen-background-mobile.png\");\n        background-size: cover;\n        background-position: center;\n        border: 3px solid #fff;\n        border-radius: 12px;\n        height: 100%;\n        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n      }\n      @media (min-aspect-ratio: 3/4) {\n        #game-over-screen .container {\n          background-image: url(\"./images/game-over-screen-background-tablet.png\");\n        }\n      }\n      #game-over-message {\n        font-size: clamp(24px, 6vw, 40px);\n        color: #e94560;\n        margin-bottom: 40px;\n      }\n    </style>\n\n    <!-- Here is the integrated Platform setup -->\n    <script>\n      if (typeof Platform === \"undefined\") {\n        // Mock Platform API for local testing\n        var Platform = {\n          majorVersion: function () {\n            return 1;\n          },\n          minorVersion: function () {\n            return 0;\n          },\n          setHighestScore: function (score) {\n            localStorage.setItem(\"triviaHighScore\", score);\n          },\n          getHighestScore: function () {\n            return parseInt(localStorage.getItem(\"triviaHighScore\")) || 0;\n          },\n          getSoundVolume: function () {\n            const stored = localStorage.getItem(\"triviaVolume\");\n            if (stored === null) {\n              // If no volume in storage yet, default to 50\n              return 50;\n            }\n            const vol = parseInt(stored, 10);\n            if (isNaN(vol) || vol < 0 || vol > 100) {\n              // If the parsed value is invalid or out of 0-100, fallback\n              return 50;\n            }\n            return vol; // Even if vol = 0, we return 0 properly\n          },\n          setSoundVolume: function (volume) {\n            localStorage.setItem(\"triviaVolume\", volume);\n          },\n          getPreferredDifficulty: function () {\n            return 3; // Default to medium\n          },\n        };\n      }\n\n      if (Platform.majorVersion() != 1) {\n        throw \"This script requires Platform version 1.x\";\n      }\n      // Provided by Platform v1.x:\n      //  - Platform.majorVersion() => number\n      //  - Platform.minorVersion() => number\n      //  - Platform.setHighestScore(score: number) => void\n      //  - Platform.getHighestScore() => number\n      //  - Platform.getSoundVolume() => number  // 0-100\n      //  - Platform.getPreferredDifficulty() => number  // 0=easy,1=medium,2=hard,3=default\n    </script>\n    <!--END You must not change anything in head tag, use them as reference only-->\n  </head>\n  <body>\n    <!-- The ONLY screen that is active on load is the Start Menu -->\n    <div class=\"screen active\" id=\"start-menu-screen\">\n      <div class=\"container\">\n        <!-- Updated game title -->\n        <h1 id=\"game-title\">Chroma Shift</h1>\n        <button id=\"play-button\">Play</button>\n        <button id=\"settings-button\">Settings</button>\n        <button id=\"instructions-button\">Instructions</button>\n      </div>\n    </div>\n\n    <!-- SETTINGS SCREEN -->\n    <div class=\"screen\" id=\"settings-screen\">\n      <div class=\"container\">\n        <h2>Settings</h2>\n        <label for=\"volume-range\">Volume:</label>\n        <input\n          type=\"range\"\n          id=\"volume-range\"\n          min=\"0\"\n          max=\"100\"\n          step=\"1\"\n          value=\"100\"\n        />\n        <button class=\"main-menu-button\" id=\"settings-back-button\">Back</button>\n      </div>\n    </div>\n\n    <!-- INSTRUCTIONS SCREEN -->\n    <div class=\"screen\" id=\"instructions-screen\">\n      <div class=\"container\">\n        <div class=\"instructions-content\">\n          <h2>Instructions</h2>\n          <p>\n            Welcome to Chroma Shift! Instead of swapping adjacent tiles, select a tile \n            and then click/tap another tile in the same row or column to rotate that row or column by one space.\n          </p>\n          <p><strong>How to Play:</strong></p>\n          <ul>\n            <li>\n              Tap/click a tile to select its row or column.\n            </li>\n            <li>\n              Then tap/click another tile in the same row (rotate left/right) or\n              same column (rotate up/down) to trigger a rotation.\n            </li>\n            <li>\n              When a valid rotation creates three or more adjacent tiles of the same color,\n              they clear from the board.\n            </li>\n            <li>\n              Special blocks can be created and activated by larger matches.\n            </li>\n            <li>\n              Complete level objectives within the limited number of moves.\n            </li>\n          </ul>\n        </div>\n        <button class=\"main-menu-button\" id=\"instructions-back-button\">\n          Back\n        </button>\n      </div>\n    </div>\n\n    <!-- GAME SCREEN -->\n    <div class=\"screen\" id=\"game-container\">\n      <!-- HUD at top -->\n      <div id=\"hud\">\n        <div id=\"hud-content\">\n          <span id=\"score-display\">Score: 0</span>\n          <span id=\"moves-display\">Moves Left: 30</span>\n          <span id=\"high-score-display\">High Score: 0</span>\n        </div>\n      </div>\n\n      <!-- Canvas container in the center -->\n      <div class=\"container\">\n        <canvas id=\"game-canvas\"></canvas>\n      </div>\n\n      <!-- Buttons at the bottom -->\n      <div id=\"game-controls\">\n        <button id=\"game-menu-button\">Menu</button>\n        <button id=\"game-restart-button\">Restart</button>\n        <button id=\"game-instructions-button\">Instructions</button>\n      </div>\n    </div>\n\n    <!-- GAME OVER SCREEN -->\n    <div class=\"screen\" id=\"game-over-screen\">\n      <div class=\"container\">\n        <div id=\"game-over-message\">Game Over!</div>\n        <div id=\"final-score\">\n          Your Score: <span id=\"final-score-value\">0</span>\n        </div>\n        <div id=\"final-high-score\">\n          High Score: <span id=\"final-high-score-value\">0</span>\n        </div>\n        <button id=\"play-again-button\">Play Again</button>\n        <button class=\"main-menu-button\" id=\"game-over-main-menu-button\">\n          Main Menu\n        </button>\n      </div>\n    </div>\n\n    <!-- AUDIO -->\n    <audio id=\"background-music\" loop>\n      <source src=\"./audio/background-music.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"start-game-sound\">\n      <source src=\"./audio/start-game-sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"end-game-sound\">\n      <source src=\"./audio/end-game-sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"powerup-sound\">\n      <source src=\"./audio/retro_powerup_sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n    <audio id=\"clear-tiles-sound\">\n      <source src=\"./audio/retro_clear_sound.mp3\" type=\"audio/mpeg\" />\n    </audio>\n\n    <!-- MAIN SCRIPT -->\n    <script>\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        class GameUI {\n          constructor(game) {\n            this.game = game;\n            this.screens = {\n              startMenu: document.getElementById(\"start-menu-screen\"),\n              settings: document.getElementById(\"settings-screen\"),\n              instructions: document.getElementById(\"instructions-screen\"),\n              game: document.getElementById(\"game-container\"),\n              gameOver: document.getElementById(\"game-over-screen\"),\n            };\n            this.hud = document.getElementById(\"hud\");\n            this.gameControls = document.getElementById(\"game-controls\");\n            this.scoreDisplay = document.getElementById(\"score-display\");\n            this.movesDisplay = document.getElementById(\"moves-display\");\n            this.highScoreDisplay =\n              document.getElementById(\"high-score-display\");\n            this.finalScoreValue = document.getElementById(\"final-score-value\");\n            this.finalHighScoreValue = document.getElementById(\n              \"final-high-score-value\"\n            );\n\n            // Settings\n            this.volumeRange = document.getElementById(\"volume-range\");\n\n            // Audio\n            this.backgroundMusic = document.getElementById(\"background-music\");\n            this.powerupSound = document.getElementById(\"powerup-sound\");\n            this.startGameSound = document.getElementById(\"start-game-sound\");\n            this.endGameSound = document.getElementById(\"end-game-sound\");\n            this.clearTilesSound = document.getElementById(\"clear-tiles-sound\");\n\n            // Initialize volume\n            const initialVolume = Platform.getSoundVolume() / 100;\n            this.setVolume(initialVolume);\n            this.volumeRange.value = initialVolume * 100;\n\n            // Listen for volume change\n            this.volumeRange.addEventListener(\"input\", (e) => {\n              const volume = e.target.value / 100;\n              this.setVolume(volume);\n              Platform.setSoundVolume(e.target.value); // persist new volume\n            });\n          }\n\n          setVolume(volume) {\n            this.backgroundMusic.volume = volume;\n            this.powerupSound.volume = volume;\n            this.startGameSound.volume = volume;\n            this.endGameSound.volume = volume;\n            this.clearTilesSound.volume = volume;\n          }\n\n          swapToScreen(screenName) {\n            // Hide all screens\n            Object.values(this.screens).forEach((scr) =>\n              scr.classList.remove(\"active\")\n            );\n            // Show the requested screen\n            this.screens[screenName].classList.add(\"active\");\n\n            if (screenName === \"game\") {\n              this.hud.style.display = \"block\";\n              // Ensure canvas reinitialized\n              this.game.logic.initCanvasSize();\n              this.game.logic.draw();\n            } else {\n              this.hud.style.display = \"none\";\n            }\n          }\n\n          startGame() {\n            this.swapToScreen(\"game\");\n            this.updateHUD();\n            if (this.backgroundMusic) {\n              this.backgroundMusic.play();\n            }\n          }\n\n          endGame() {\n            this.playEndGameSound();\n            if (this.backgroundMusic) {\n              this.backgroundMusic.pause();\n              this.backgroundMusic.currentTime = 0;\n            }\n            this.swapToScreen(\"gameOver\");\n            this.finalScoreValue.textContent = this.game.score;\n            this.finalHighScoreValue.textContent = this.game.highScore;\n          }\n\n          mainMenu() {\n            if (this.backgroundMusic) {\n              this.backgroundMusic.pause();\n              this.backgroundMusic.currentTime = 0;\n            }\n            this.swapToScreen(\"startMenu\");\n          }\n\n          playAgain() {\n            this.game.resetGame();\n            this.swapToScreen(\"game\");\n          }\n\n          settings() {\n            this.swapToScreen(\"settings\");\n          }\n\n          instructions() {\n            this.swapToScreen(\"instructions\");\n          }\n\n          updateHUD() {\n            this.scoreDisplay.textContent = \"Score: \" + this.game.score;\n            this.movesDisplay.textContent =\n              \"Moves Left: \" + this.game.logic.movesLeft;\n            this.highScoreDisplay.textContent =\n              \"High Score: \" + this.game.highScore;\n          }\n\n          playPowerupSound() {\n            this.powerupSound.currentTime = 0;\n            this.powerupSound.play();\n          }\n\n          playStartGameSound() {\n            this.startGameSound.currentTime = 0;\n            this.startGameSound.play();\n          }\n\n          playEndGameSound() {\n            this.endGameSound.currentTime = 0;\n            this.endGameSound.play();\n          }\n\n          playClearTilesSound() {\n            this.clearTilesSound.currentTime = 0;\n            this.clearTilesSound.play();\n          }\n        }\n\n        class GameLogic {\n          constructor(game) {\n            this.game = game;\n            this.canvas = document.getElementById(\"game-canvas\");\n            this.context = this.canvas.getContext(\"2d\");\n            this.gridSize = 10;\n            this.tileTypes = 6;\n            this.tileSize = null;\n            this.grid = [];\n            this.selectedTile = null;\n            this.animations = [];\n            this.score = 0;\n            this.highScore = 0;\n            this.movesLeft = 30;\n            this.isAnimating = false;\n            this.pendingSpecialTiles = [];\n            this.lastSwappedTile = null;\n            this.delayCounter = 0;\n            this.pendingAnimations = null;\n            this.specialBlocks = [\"BOMB\", \"LIGHTNING\", \"FIRECRACKER\"];\n            this.initCanvasSize();\n            window.addEventListener(\"resize\", () => {\n              this.initCanvasSize();\n              this.draw();\n            });\n            this.init();\n          }\n\n          initCanvasSize() {\n            const container = document.querySelector(\n              \"#game-container .container\"\n            );\n            const containerWidth = container.clientWidth;\n            const containerHeight = container.clientHeight;\n            const canvasSize = Math.min(containerWidth, containerHeight);\n            this.canvas.width = canvasSize;\n            this.canvas.height = canvasSize;\n            this.tileSize = canvasSize / this.gridSize;\n          }\n\n          init() {\n            this.generateGrid();\n            this.bindEvents();\n            this.update();\n            this.draw();\n          }\n\n          resetGame() {\n            this.score = 0;\n            this.movesLeft = 30;\n            this.grid = [];\n            this.selectedTile = null;\n            this.animations = [];\n            this.isAnimating = false;\n            this.pendingSpecialTiles = [];\n            this.lastSwappedTile = null;\n            this.delayCounter = 0;\n            this.pendingAnimations = null;\n            this.generateGrid();\n            this.game.ui.updateHUD();\n          }\n\n          generateGrid() {\n            for (let x = 0; x < this.gridSize; x++) {\n              this.grid[x] = [];\n              for (let y = 0; y < this.gridSize; y++) {\n                this.grid[x][y] = this.getRandomTile();\n              }\n            }\n            this.removeInitialMatches();\n          }\n\n          getRandomTile() {\n            return {\n              type: Math.floor(Math.random() * this.tileTypes),\n              special: null,\n              x: 0,\n              y: 0,\n              isMoving: false,\n              moveTo: null,\n            };\n          }\n\n          removeInitialMatches() {\n            let matches = this.findAllMatches();\n            while (matches.length > 0) {\n              for (let match of matches) {\n                for (let tile of match.tiles) {\n                  this.grid[tile.x][tile.y] = this.getRandomTile();\n                }\n              }\n              matches = this.findAllMatches();\n            }\n          }\n\n          bindEvents() {\n            let isTouchDevice =\n              \"ontouchstart\" in window || navigator.msMaxTouchPoints;\n\n            if (isTouchDevice) {\n              this.canvas.addEventListener(\n                \"touchstart\",\n                this.onTouchStart.bind(this),\n                { passive: false }\n              );\n              // Disable move and end events for rotation mechanic\n              this.canvas.addEventListener(\n                \"touchmove\",\n                (e) => { e.preventDefault(); },\n                { passive: false }\n              );\n              this.canvas.addEventListener(\n                \"touchend\",\n                (e) => { this.selectedTile = null; },\n                { passive: false }\n              );\n            } else {\n              // For desktop, only use onMouseDown to handle rotation selection.\n              this.canvas.addEventListener(\n                \"mousedown\",\n                this.onMouseDown.bind(this)\n              );\n              // Disable mousemove and mouseup events for rotation mechanic.\n              this.canvas.addEventListener(\"mousemove\", (e) => {}, false);\n              this.canvas.addEventListener(\"mouseup\", (e) => {\n                this.selectedTile = null;\n              }, false);\n            }\n          }\n\n          getTileUnderCursor(event) {\n            let rect = this.canvas.getBoundingClientRect();\n            let posX =\n              (event.clientX - rect.left) * (this.canvas.width / rect.width);\n            let posY =\n              (event.clientY - rect.top) * (this.canvas.height / rect.height);\n            let tileX = Math.floor(posX / this.tileSize);\n            let tileY = Math.floor(posY / this.tileSize);\n            return { x: tileX, y: tileY };\n          }\n\n          // Modified onMouseDown to handle row/column rotation\n          onMouseDown(e) {\n            if (this.isAnimating) return;\n            let pos = this.getTileUnderCursor(e);\n            if (!this.isValidTile(pos)) return;\n            if (!this.selectedTile) {\n              this.selectedTile = pos;\n              return;\n            }\n            if (pos.y === this.selectedTile.y) {\n              let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n              this.rotateRow(this.selectedTile.y, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else if (pos.x === this.selectedTile.x) {\n              let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n              this.rotateColumn(this.selectedTile.x, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else {\n              this.selectedTile = pos;\n            }\n          }\n\n          // Modified onTouchStart similar to onMouseDown for rotation\n          onTouchStart(e) {\n            if (this.isAnimating) return;\n            let touch = e.touches[0];\n            if (this.isTouchInCanvas(touch)) {\n              e.preventDefault();\n            }\n            let pos = this.getTileUnderCursor(touch);\n            if (!this.isValidTile(pos)) return;\n            if (!this.selectedTile) {\n              this.selectedTile = pos;\n              return;\n            }\n            if (pos.y === this.selectedTile.y) {\n              let direction = (pos.x > this.selectedTile.x) ? \"right\" : \"left\";\n              this.rotateRow(this.selectedTile.y, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else if (pos.x === this.selectedTile.x) {\n              let direction = (pos.y > this.selectedTile.y) ? \"down\" : \"up\";\n              this.rotateColumn(this.selectedTile.x, direction);\n              this.movesLeft--;\n              this.game.ui.updateHUD();\n              let newMatches = this.findAllMatches();\n              if (newMatches.length > 0) {\n                this.processMatches(newMatches);\n              } else {\n                if (this.movesLeft <= 0) {\n                  this.game.endGame();\n                }\n                this.isAnimating = false;\n              }\n              this.selectedTile = null;\n            } else {\n              this.selectedTile = pos;\n            }\n          }\n\n          isValidTile(pos) {\n            return (\n              pos.x >= 0 &&\n              pos.x < this.gridSize &&\n              pos.y >= 0 &&\n              pos.y < this.gridSize\n            );\n          }\n\n          // New helper function to rotate a row by one space.\n          rotateRow(row, direction) {\n            if (direction === \"right\") {\n              const temp = this.grid[row][this.gridSize - 1];\n              for (let x = this.gridSize - 1; x > 0; x--) {\n                this.grid[row][x] = this.grid[row][x - 1];\n              }\n              this.grid[row][0] = temp;\n            } else if (direction === \"left\") {\n              const temp = this.grid[row][0];\n              for (let x = 0; x < this.gridSize - 1; x++) {\n                this.grid[row][x] = this.grid[row][x + 1];\n              }\n              this.grid[row][this.gridSize - 1] = temp;\n            }\n          }\n\n          // New helper function to rotate a column by one space.\n          rotateColumn(col, direction) {\n            if (direction === \"down\") {\n              const temp = this.grid[this.gridSize - 1][col];\n              for (let y = this.gridSize - 1; y > 0; y--) {\n                this.grid[y][col] = this.grid[y - 1][col];\n              }\n              this.grid[0][col] = temp;\n            } else if (direction === \"up\") {\n              const temp = this.grid[0][col];\n              for (let y = 0; y < this.gridSize - 1; y++) {\n                this.grid[y][col] = this.grid[y + 1][col];\n              }\n              this.grid[this.gridSize - 1][col] = temp;\n            }\n          }\n\n          findAllMatches() {\n            let matches = [];\n            // Horizontal matches\n            for (let y = 0; y < this.gridSize; y++) {\n              let matchLength = 1;\n              for (let x = 0; x < this.gridSize; x++) {\n                if (x < this.gridSize - 1) {\n                  let currentTile = this.grid[x][y];\n                  let nextTile = this.grid[x + 1][y];\n                  if (\n                    currentTile &&\n                    nextTile &&\n                    currentTile.type === nextTile.type\n                  ) {\n                    matchLength++;\n                  } else {\n                    if (matchLength >= 3) {\n                      let tiles = [];\n                      for (let i = x - matchLength + 1; i <= x; i++) {\n                        tiles.push({ x: i, y: y });\n                      }\n                      matches.push({\n                        type: this.grid[x][y].type,\n                        tiles: tiles,\n                      });\n                    }\n                    matchLength = 1;\n                  }\n                } else {\n                  if (matchLength >= 3) {\n                    let tiles = [];\n                    for (let i = x - matchLength + 1; i <= x; i++) {\n                      tiles.push({ x: i, y: y });\n                    }\n                    matches.push({\n                      type: this.grid[x][y].type,\n                      tiles: tiles,\n                    });\n                  }\n                  matchLength = 1;\n                }\n              }\n            }\n            // Vertical matches\n            for (let x = 0; x < this.gridSize; x++) {\n              let matchLength = 1;\n              for (let y = 0; y < this.gridSize; y++) {\n                if (y < this.gridSize - 1) {\n                  let currentTile = this.grid[x][y];\n                  let nextTile = this.grid[x][y + 1];\n                  if (\n                    currentTile &&\n                    nextTile &&\n                    currentTile.type === nextTile.type\n                  ) {\n                    matchLength++;\n                  } else {\n                    if (matchLength >= 3) {\n                      let tiles = [];\n                      for (let i = y - matchLength + 1; i <= y; i++) {\n                        tiles.push({ x: x, y: i });\n                      }\n                      matches.push({\n                        type: this.grid[x][y].type,\n                        tiles: tiles,\n                      });\n                    }\n                    matchLength = 1;\n                  }\n                } else {\n                  if (matchLength >= 3) {\n                    let tiles = [];\n                    for (let i = y - matchLength + 1; i <= y; i++) {\n                      tiles.push({ x: x, y: i });\n                    }\n                    matches.push({\n                      type: this.grid[x][y].type,\n                      tiles: tiles,\n                    });\n                  }\n                  matchLength = 1;\n                }\n              }\n            }\n            return matches;\n          }\n\n          mergeOverlappingMatches(matches) {\n            let mergedMatches = [];\n            for (let match of matches) {\n              let merged = false;\n              for (let existingMatch of mergedMatches) {\n                if (this.matchesOverlap(existingMatch, match)) {\n                  existingMatch.tiles = existingMatch.tiles.concat(\n                    match.tiles.filter(\n                      (t) =>\n                        !existingMatch.tiles.some(\n                          (et) => et.x === t.x && et.y === t.y\n                        )\n                    )\n                  );\n                  merged = true;\n                  break;\n                }\n              }\n              if (!merged) {\n                mergedMatches.push({\n                  type: match.type,\n                  tiles: [...match.tiles],\n                });\n              }\n            }\n            let hasMerged = true;\n            while (hasMerged) {\n              hasMerged = false;\n              for (let i = 0; i < mergedMatches.length; i++) {\n                for (let j = i + 1; j < mergedMatches.length; j++) {\n                  if (this.matchesOverlap(mergedMatches[i], mergedMatches[j])) {\n                    mergedMatches[i].tiles = mergedMatches[i].tiles.concat(\n                      mergedMatches[j].tiles.filter(\n                        (t) =>\n                          !mergedMatches[i].tiles.some(\n                            (et) => et.x === t.x && et.y === t.y\n                          )\n                      )\n                    );\n                    mergedMatches.splice(j, 1);\n                    hasMerged = true;\n                    break;\n                  }\n                }\n                if (hasMerged) break;\n              }\n            }\n            return mergedMatches;\n          }\n\n          matchesOverlap(a, b) {\n            for (let tile1 of a.tiles) {\n              for (let tile2 of b.tiles) {\n                if (tile1.x === tile2.x && tile1.y === tile2.y) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          }\n\n          processMatches(matches) {\n            let mergedMatches = this.mergeOverlappingMatches(matches);\n            let tilesToClear = [];\n            for (let match of mergedMatches) {\n              let tiles = match.tiles;\n              let matchLength = tiles.length;\n              for (let tile of tiles) {\n                if (\n                  !tilesToClear.some((t) => t.x === tile.x && t.y === tile.y)\n                ) {\n                  tilesToClear.push({ x: tile.x, y: tile.y });\n                }\n              }\n              if (matchLength >= 4) {\n                let specialType = null;\n                if (matchLength === 4) specialType = \"BOMB\";\n                else if (matchLength === 5) specialType = \"LIGHTNING\";\n                else if (matchLength >= 6) specialType = \"FIRECRACKER\";\n                if (specialType) {\n                  let specialTile = this.getSpecialTilePosition(tiles);\n                  this.pendingSpecialTiles.push({\n                    x: specialTile.x,\n                    y: specialTile.y,\n                    type: specialType,\n                    colorType: this.grid[specialTile.x][specialTile.y].type,\n                  });\n                }\n              }\n              this.game.score += tiles.length * 10;\n              this.game.ui.updateHUD();\n            }\n            this.game.ui.playClearTilesSound();\n            this.isAnimating = true;\n            this.delayCounter = 30;\n            this.pendingAnimations = {\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            };\n          }\n\n          getSpecialTilePosition(tiles) {\n            if (this.lastSwappedTile) {\n              for (let tile of tiles) {\n                if (\n                  tile.x === this.lastSwappedTile.x &&\n                  tile.y === this.lastSwappedTile.y\n                ) {\n                  return tile;\n                }\n              }\n            }\n            return tiles[Math.floor(tiles.length / 2)];\n          }\n\n          clearTiles(tiles) {\n            for (let tile of tiles) {\n              let x = tile.x;\n              let y = tile.y;\n              let currentTile = this.grid[x][y];\n              if (currentTile) {\n                if (currentTile.special) {\n                  this.activateSpecialTile(x, y);\n                }\n                this.grid[x][y] = null;\n              }\n            }\n          }\n\n          activateSpecialTile(x, y) {\n            let tile = this.grid[x][y];\n            if (tile && tile.special) {\n              this.game.ui.playPowerupSound();\n              if (tile.special === \"BOMB\") {\n                this.activateBomb(x, y);\n              } else if (tile.special === \"LIGHTNING\") {\n                this.activateLightning(x, y, tile.type);\n              } else if (tile.special === \"FIRECRACKER\") {\n                this.activateFirecracker(x, y);\n              }\n              this.grid[x][y] = null;\n            }\n          }\n\n          findAllMatches() { /* Already defined above */ }\n\n          activateBomb(x, y) {\n            let tilesToClear = [];\n            for (let i = x - 1; i <= x + 1; i++) {\n              for (let j = y - 1; j <= y + 1; j++) {\n                if (this.isValidTile({ x: i, y: j }) && this.grid[i][j]) {\n                  tilesToClear.push({ x: i, y: j });\n                }\n              }\n            }\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          activateLightning(x, y, type) {\n            let tilesToClear = [];\n            let cleared = 0;\n            for (let i = 0; i < this.gridSize; i++) {\n              for (let j = 0; j < this.gridSize; j++) {\n                if (this.grid[i][j] && this.grid[i][j].type === type) {\n                  tilesToClear.push({ x: i, y: j });\n                  cleared++;\n                  if (cleared >= 9) break;\n                }\n              }\n              if (cleared >= 9) break;\n            }\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          activateFirecracker(x, y) {\n            let tilesToClear = [];\n            for (let i = 0; i < this.gridSize; i++) {\n              if (this.grid[i][y]) {\n                tilesToClear.push({ x: i, y: y });\n              }\n            }\n            for (let j = 0; j < this.gridSize; j++) {\n              if (this.grid[x][j]) {\n                tilesToClear.push({ x: x, y: j });\n              }\n            }\n            tilesToClear = tilesToClear.filter(\n              (tile, index, self) =>\n                index ===\n                self.findIndex((t) => t.x === tile.x && t.y === tile.y)\n            );\n            this.game.score += tilesToClear.length * 10;\n            this.game.ui.updateHUD();\n            this.animations.push({\n              type: \"fade\",\n              tiles: tilesToClear,\n              progress: 0,\n              duration: 15,\n            });\n          }\n\n          fillEmptySpaces() {\n            let moved = false;\n            for (let x = 0; x < this.gridSize; x++) {\n              for (let y = this.gridSize - 1; y >= 0; y--) {\n                if (this.grid[x][y] === null) {\n                  for (let yy = y - 1; yy >= 0; yy--) {\n                    if (this.grid[x][yy] !== null) {\n                      this.grid[x][yy].isMoving = true;\n                      this.grid[x][yy].moveTo = { x: x, y: y };\n                      this.animations.push({\n                        type: \"fall\",\n                        tile: this.grid[x][yy],\n                        from: { x: x, y: yy },\n                        to: { x: x, y: y },\n                        progress: 0,\n                        duration: (yy - y) * 5,\n                      });\n                      this.grid[x][y] = this.grid[x][yy];\n                      this.grid[x][yy] = null;\n                      moved = true;\n                      break;\n                    }\n                  }\n                  if (this.grid[x][y] === null) {\n                    let newTile = this.getRandomTile();\n                    newTile.isMoving = true;\n                    newTile.moveTo = { x: x, y: y };\n                    this.grid[x][y] = newTile;\n                    this.animations.push({\n                      type: \"fall\",\n                      tile: newTile,\n                      from: { x: x, y: y - this.gridSize },\n                      to: { x: x, y: y },\n                      progress: 0,\n                      duration: (this.gridSize + y) * 5,\n                    });\n                    moved = true;\n                  }\n                }\n              }\n            }\n            if (this.pendingSpecialTiles.length > 0) {\n              for (let specialTileInfo of this.pendingSpecialTiles) {\n                let x = specialTileInfo.x;\n                let y = specialTileInfo.y;\n                this.grid[x][y] = {\n                  type: specialTileInfo.colorType,\n                  special: specialTileInfo.type,\n                  x: 0,\n                  y: 0,\n                  isMoving: false,\n                  moveTo: null,\n                };\n              }\n              this.pendingSpecialTiles = [];\n            }\n            return moved;\n          }\n\n          update() {\n            if (this.delayCounter > 0) {\n              this.delayCounter--;\n              if (this.delayCounter === 0 && this.pendingAnimations) {\n                this.animations.push(this.pendingAnimations);\n                this.pendingAnimations = null;\n              }\n            } else {\n              if (this.animations.length > 0) {\n                for (let i = this.animations.length - 1; i >= 0; i--) {\n                  let anim = this.animations[i];\n                  anim.progress++;\n                  if (anim.progress >= anim.duration) {\n                    this.animations.splice(i, 1);\n                    if (anim.type === \"swap\") {\n                      if (anim.reverse) {\n                        let temp =\n                          this.grid[anim.tiles[0].from.x][anim.tiles[0].from.y];\n                        this.grid[anim.tiles[0].from.x][anim.tiles[0].from.y] =\n                          this.grid[anim.tiles[1].from.x][anim.tiles[1].from.y];\n                        this.grid[anim.tiles[1].from.x][anim.tiles[1].from.y] =\n                          temp;\n                        this.isAnimating = false;\n                      } else {\n                        this.processSwap(anim.tiles[0].from, anim.tiles[0].to);\n                      }\n                    } else if (anim.type === \"fade\") {\n                      this.clearTiles(anim.tiles);\n                      if (!this.fillEmptySpaces()) {\n                        let newMatches = this.findAllMatches();\n                        if (newMatches.length > 0) {\n                          this.processMatches(newMatches);\n                        } else {\n                          this.isAnimating = false;\n                          if (this.movesLeft <= 0) {\n                            this.game.endGame();\n                          }\n                        }\n                      }\n                    } else if (anim.type === \"fall\") {\n                      anim.tile.isMoving = false;\n                      anim.tile.moveTo = null;\n                      if (this.animations.length === 0) {\n                        let newMatches = this.findAllMatches();\n                        if (newMatches.length > 0) {\n                          this.processMatches(newMatches);\n                        } else {\n                          this.isAnimating = false;\n                          if (this.movesLeft <= 0) {\n                            this.game.endGame();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            this.draw();\n            requestAnimationFrame(this.update.bind(this));\n          }\n\n          draw() {\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            for (let x = 0; x < this.gridSize; x++) {\n              for (let y = 0; y < this.gridSize; y++) {\n                let tile = this.grid[x][y];\n                if (tile) {\n                  this.drawTile(x, y, tile);\n                }\n              }\n            }\n            if (this.selectedTile) {\n              this.context.strokeStyle = \"#FFD700\";\n              this.context.lineWidth = 5;\n              this.context.strokeRect(\n                this.selectedTile.x * this.tileSize,\n                this.selectedTile.y * this.tileSize,\n                this.tileSize,\n                this.tileSize\n              );\n            }\n          }\n\n          drawTile(x, y, tile) {\n            let drawX = x;\n            let drawY = y;\n            for (let anim of this.animations) {\n              if (anim.type === \"swap\") {\n                for (let t of anim.tiles) {\n                  if (t.from.x === x && t.from.y === y) {\n                    let progress = anim.progress / anim.duration;\n                    if (anim.reverse) progress = 1 - progress;\n                    drawX = t.from.x + (t.to.x - t.from.x) * progress;\n                    drawY = t.from.y + (t.to.y - t.from.y) * progress;\n                  }\n                }\n              } else if (anim.type === \"fall\" && tile.isMoving) {\n                if (tile.moveTo) {\n                  let progress = anim.progress / anim.duration;\n                  drawX = anim.from.x;\n                  drawY = anim.from.y + (anim.to.y - anim.from.y) * progress;\n                }\n              } else if (anim.type === \"fade\") {\n                for (let fadeTile of anim.tiles) {\n                  if (fadeTile.x === x && fadeTile.y === y) {\n                    let alpha = 1 - anim.progress / anim.duration;\n                    this.context.globalAlpha = alpha;\n                  }\n                }\n              }\n            }\n            let colors = [\n              \"#FF0000\",\n              \"#00FF00\",\n              \"#0000FF\",\n              \"#FFFF00\",\n              \"#FF00FF\",\n              \"#00FFFF\",\n            ];\n            this.context.fillStyle = colors[tile.type];\n            this.context.fillRect(\n              drawX * this.tileSize,\n              drawY * this.tileSize,\n              this.tileSize,\n              this.tileSize\n            );\n            if (tile.special) {\n              this.context.fillStyle = \"#999999\";\n              this.context.font = `${this.tileSize / 2}px Arial`;\n              this.context.textAlign = \"center\";\n              this.context.textBaseline = \"middle\";\n              let text = \"\";\n              if (tile.special === \"BOMB\") text = \"B\";\n              else if (tile.special === \"LIGHTNING\") text = \"L\";\n              else if (tile.special === \"FIRECRACKER\") text = \"F\";\n              this.context.fillText(\n                text,\n                drawX * this.tileSize + this.tileSize / 2,\n                drawY * this.tileSize + this.tileSize / 2\n              );\n            }\n            this.context.globalAlpha = 1;\n            this.context.strokeStyle = \"#000\";\n            this.context.lineWidth = 2;\n            this.context.strokeRect(\n              drawX * this.tileSize,\n              drawY * this.tileSize,\n              this.tileSize,\n              this.tileSize\n            );\n          }\n        }\n\n        class Game {\n          constructor() {\n            this.score = 0;\n            this.highScore = Platform.getHighestScore() || 0;\n            this.ui = new GameUI(this);\n            this.logic = null;\n          }\n\n          startGame() {\n            this.score = 0;\n            if (this.logic) {\n              this.logic.resetGame();\n            } else {\n              this.logic = new GameLogic(this);\n            }\n            switch (Platform.getPreferredDifficulty()) {\n              case 0:\n                this.logic.movesLeft = 50;\n                break;\n              case 1:\n                this.logic.movesLeft = 30;\n                break;\n              case 2:\n                this.logic.movesLeft = 20;\n                break;\n              default:\n                this.logic.movesLeft = 30;\n                break;\n            }\n            this.ui.startGame();\n            this.ui.updateHUD();\n          }\n\n          endGame() {\n            this.ui.playEndGameSound();\n            if (this.score > this.highScore) {\n              this.highScore = this.score;\n              Platform.setHighestScore(this.highScore);\n            }\n            this.ui.endGame();\n          }\n\n          resetGame() {\n            this.score = 0;\n            this.ui.updateHUD();\n            this.logic.resetGame();\n          }\n\n          assignButtons() {\n            const playButton = document.getElementById(\"play-button\");\n            const settingsButton = document.getElementById(\"settings-button\");\n            const instructionsButton = document.getElementById(\n              \"instructions-button\"\n            );\n            const playAgainButton =\n              document.getElementById(\"play-again-button\");\n            const mainMenuButtons =\n              document.querySelectorAll(\".main-menu-button\");\n            const gameMenuButton = document.getElementById(\"game-menu-button\");\n            const gameRestartButton = document.getElementById(\n              \"game-restart-button\"\n            );\n            const gameInstructionsButton = document.getElementById(\n              \"game-instructions-button\"\n            );\n            const instructionsBackButton = document.getElementById(\n              \"instructions-back-button\"\n            );\n            const settingsBackButton = document.getElementById(\n              \"settings-back-button\"\n            );\n\n            playButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            settingsButton.addEventListener(\"click\", () => {\n              this.ui.settings();\n            });\n            instructionsButton.addEventListener(\"click\", () => {\n              this.ui.instructions();\n            });\n            playAgainButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            mainMenuButtons.forEach((button) =>\n              button.addEventListener(\"click\", () => {\n                this.ui.mainMenu();\n              })\n            );\n            gameMenuButton.addEventListener(\"click\", () => {\n              this.endGame();\n              this.ui.mainMenu();\n            });\n            gameRestartButton.addEventListener(\"click\", () => {\n              this.startGame();\n            });\n            gameInstructionsButton.addEventListener(\"click\", () => {\n              this.ui.instructions();\n            });\n            instructionsBackButton.addEventListener(\"click\", () => {\n              if (this.ui.screens.game.classList.contains(\"active\")) {\n                this.ui.swapToScreen(\"game\");\n              } else {\n                this.ui.mainMenu();\n              }\n            });\n            settingsBackButton.addEventListener(\"click\", () => {\n              this.ui.mainMenu();\n            });\n          }\n\n          prepareGame() {\n            this.assignButtons();\n            this.ui.highScoreDisplay.textContent =\n              \"High Score: \" + this.highScore;\n          }\n        }\n\n        const game = new Game();\n        game.prepareGame();\n      });\n    </script>\n  </body>\n</html>\nHTML-CONTENT-EXPORT-END\n--------------------------------------------------------------\n\n5. Constraints and Limitations  \n• All modifications have been made within the original HTML file. No external libraries or assets have been added.  \n• The new rotation mechanic replaces the swap mechanism; any further advanced animations or UI indicators (such as dedicated row/column selectors) can be implemented later but are not required at this stage.  \n\nYou now have a modified version of the game where the gameplay for Chroma Shift is based on row/column rotations with updated title and mechanic logic.","refusal":null},"finish_reason":"stop"}],"usage":{"prompt_tokens":13697,"completion_tokens":16231,"total_tokens":29928,"prompt_tokens_details":{"cached_tokens":12288,"audio_tokens":0},"completion_tokens_details":{"reasoning_tokens":2944,"audio_tokens":0,"accepted_prediction_tokens":0,"rejected_prediction_tokens":0}},"service_tier":"default","system_fingerprint":"fp_ef58bd3122"}}